
/* 24.12.1.3 */

/* 24.36.1.3 */

// Fiber product of 3C0-3a and 2C0-8b.

F<x,y> := FunctionField(Rationals(),2);

// Compute the two j-maps
j1 := ((x-9)*(x+3)/x)^3;
t := -32*(y^2-2);
j2 := (256-t)^3/t^2;
// Set them equal
pol := Numerator(j1-j2);

// This gives a curve of genus 1
C := ProjectiveClosure(Curve(AffineSpace(Rationals(),2),pol));

// Find a non-singular point.
pt := C![-1,2,1];
// Map to elliptic curve

E, phi := EllipticCurve(C,pt);
E2, phi2 := MinimalModel(E);

// Rebuild map back
jmap1 := Inverse(phi2);

// This next line takes quite a while.
chk, jmap2 := IsInvertible(phi);

jline := ProjectiveSpace(Rationals(),1);
jmap3 := map<C -> jline | [(C.1-9*C.3)^3*(C.1+3*C.3)^3,C.1^3*C.3^3]>;

j := jmap1*jmap2*jmap3;

// Generators of Mordell-Weil group of E2

T := E2![4,0];
P := E2![10,-24];
O := E2![0,1,0];

j(T) eq j(O); // true

/* 24.36.1.8 */

// Fiber product of 3C0-3a and 4B0-8a.

F<x,y> := FunctionField(Rationals(),2);

// Compute the two j-maps
j1 := ((x-9)*(x+3)/x)^3;
t := -512/(y^2-8);
j2 := (256-t)^3/t^2;
// Set them equal
pol := Numerator(j1-j2);

// This gives a curve of genus 1
C := ProjectiveClosure(Curve(AffineSpace(Rationals(),2),pol));

// Find a non-singular point.
pt := C![-1,2,1];
// Map to elliptic curve

E, phi := EllipticCurve(C,pt);
E2, phi2 := MinimalModel(E);

// Rebuild map back
jmap1 := Inverse(phi2);

// This next line takes quite a while.
chk, jmap2 := IsInvertible(phi);

jline := ProjectiveSpace(Rationals(),1);
jmap3 := map<C -> jline | [(C.1-9*C.3)^3*(C.1+3*C.3)^3,C.1^3*C.3^3]>;

j := jmap1*jmap2*jmap3;

// Generators of Mordell-Weil group of E2

T := E2![4,0];
P := E2![10,-24];
O := E2![0,1,0];

j(T) eq j(O); // true
